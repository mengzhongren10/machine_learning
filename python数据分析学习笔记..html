Python包Pandas学习笔记

1 package的载入

  import numpy as np
  import pandas as pd

2 数据读取(“/”暂作“或”使用)
    # \s+是利用空白符进行分割,可使用正则表达式匹配
    # header可以制定列明对应的行数，如果没有就是None
    # index_col就是行名对应的列数，如果没有也是None
    # parse_dates日期型列
    pd.read_csv(path, sep = '\s+'/'\t'/',', header=0/None, usecols=[...], 
	,parse_dates=[0]/['Date'], index_col=0/None, encoding='utf-8' )

3 数据输出
    # na_rep是填充的缺失值
    # header可以给一个list用作数据输出的列名
    # columns可以给定数字list用于选取输出特定的列
    pd.to_csv(path, sep='', na_rep='NA', header=True/['xx','xx'], index=True, 
	columns=[1,2,3..], encoding='utf-8')

4 创建 DataFrame，Series对象
    
    # DataFrame和Series都接受list和numpy array数据，若要转换回array可以用df.values或S.values
    # DataFrame还可以接受dictionary对象
    df = pd.DataFrame(np.random.rand(10,5),columns=list('ABCDE')) #列名为ABCDE
    S = pd.Series([1,2,3,4])

5 数据类型总结

    df = pd.DataFrame({'string':list('abc'),
                       'int64':list(range(1,4)),
                       'uint8': np.arange(3, 6).astype('u1'),
                       'float64': np.arange(4.0, 7.0),
                       'bool1': [True, False, True],
                       'dates': pd.date_range('now', periods=3).values,
                       'category': pd.Series(list("ABC")).astype('category')
                            })
    

    S.astype(np.int64) # 数据类型转化
    S.dtype == np.int64 # 数据类型判断
    S.to_frame() # 将Series数据转换为DataFrame数据
    pd.to_datetime(df.a) # 将df数据a列转换为datetime类型
    pd.to_numeric(aDF.loc[:, 'xxx'])  #转换成数字
    df.apply(lambda x:x)     #将groupby 对象转成DataFrame类型

6 查看数据

    df.head(10) # 查看数据前10行
    df.tail(10) # 查看数据后10行
    df.shape    # 数据对应的行列数
    df.info()   # 数据索引，类型，内存信息
    df.describe(include = 'all') # 对于数字型数据进行分位数统计,all代表对所有数据类型统计
    S.value_counts(dropna=False) # 对Series里面的值进行个数统计，NA也会统计
    df.apply(pd.Series.value_counts) #返回每个值在各列中的个数，没有则用NaN代替
    df.index # 返回数据的索引
    df.columns # 返回数据的列名
    df.mean()/min()/median()/std()/count() # 分别是df的列均值,最小值,中位数,标准差,非空值
    df.corr() # 列之间的相关系数
    df.idxmax(0) # 每列最大数对应行的index的名
    df.idxmax(1) # 每行最大数对应的列名
    aDF.nsmallest(columns='age', n=20) # 取出年龄最小的20个数据
    S.is_unique # 确定Series数据是否是unique的, 返回bool值

    数值型变量
    # describe函数查看部分变量的分布
    df.describe()
  
    分类变量
    df.describe(include=[np.object])
    # count: 非缺失值的个数
    # unique: 非重复值得个数
    # top: 最高频值
    # freq: 最高频值出现次数
    
7  数据的截取
    df.xxx / df['xxx'] #返回数据的某一列，列名为xxx，类型为Series
    df[['xx','yy']] #选取多列数据，数据类型为DataFrame
    df.iloc[3] #选取第4行数据
    df.iloc[[1,2,3],:] #选取多行数据
    df.loc[['x','y','z'],['a','b','c']] #根据行index名和列名进行数据截取
    df.ix[..,..] # ix是用行名列名以及行数列数混合赋值的情况下数据的截取
    df[(df.col>0.5) & (df.col<10)] # 筛选col大于0.5小于10的行返回
    aDF.loc[(aDF['a']>10) & (aDF['b']<100), :] # 也可以给条件进行筛选,& | ~进行逻辑运算
    df.values #返回df对应的numpy array值
    df.values[10][5] #求df数据11行6列的值
    df[df['xxx'].notnull(), :] = 10 # 对空值赋值	?
    S.str.startswith('G')   #Seriers以G开头的字符, 返回bool值
    S != 'xxx'              # Series中不为xxx的位置, 返回bool值
    S.isin(['a','b','c'])   # 返回bool值如果S在list['a','b','c']中, 返回true

8 数据清洗
    del df['a'] #删除数据df的a列
    df.drop(['B','C'],axis=1,inplace=True)  # 删除数据df的B,C列, 在原数据上进行修改
    df.dropna(how = 'all',axis = 0)   #对行进行操作,如果一行里面全都是na那么就删除,如果要一列里面全是na就删除,那么axis=1
    df.loc[:, 'newcol'] = 2000        # 如果没有newcol那么就新加一列
    df['newcol'] = 2000               # df新添加一列
    df.columns = ['a','b']      # 更改数据的列名
    df.isnull().sum()           # 统计各列中缺失值的个数
    df.notnull().sum()          # 统计各列中非缺失值的个数
    df.drop_duplicates([...], 'first'/'last'/False)   # 移除重复项, list可以是列名也可以是数字序列,first是保留重复中的第一个, last是保留重复中的最后一个, False一个不留, 只要重复都删除
    df.dropna(axis=0/1, how='any'/'all', thresh=n)   # 移除数据中的缺失行,axis0是行删除,1是列删除
                                                     # any是只要有一个就删除,all是所有的都是才删除
                                                     # thresh目的是大于n个NA才删除
    S.fillna(x)      #对缺失值进行填充，填充值为x
    aDF.loc[:,'xx'].fillna(aSeires)    # 对数据进行填充,根据aSeires的index和aDF的index进行填充				    
    S.astype(np.float) # 数据的类型转换
    S.replace(1, 'one') # 将1替换为'one'
    S.replace([1,2], ['one','two']) # 将1替换为one, 2替换为two
    df.rename(index/columns={'old1':'new1','old2':'new2'}) # 修改行名列名，将old1改为new1，将old2改为new2
    df.set_index('B') # 修改index，将B所在的列作为行索引
    df.sort_index() # 将数据按照index进行排序
    df.sort_values([col1, col2], ascending=[True,False]) # 根据col1和col2的值进行排序，col1是升序，col2是降序
    S.argsort() # 返回Series对应的值的order，S[S.argsort()]返回的是对应的从小到大的Series数值			    
    df.reset_index(drop=False/True, inplace=False/True) # 数据的index换成从0开始的, drop是说是否保留原来的index, 保留的话就多一列, inplace是说是否修改原来的df
    data['Age'] = pd.cut(data['Age'], bins=6, labels=np.arange(6)) # 对数值型数据进行区间分割，分割成6个bin，label用0-5表示
    np.tile(a, N).flatten() # 对数据a进行重复
					    
					    
					    
					    
					    
					    
					    
					    
					    
